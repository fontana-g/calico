(* ::Package:: *)

BeginPackage["CALICO`",{"FiniteFlow`"}]


CATSyz::usage = "\
CATSyz[polys,vars,maxdeg] returns solutions for the syzygy equations defined by the list of polynomials 'polys' \
up to degree 'maxdeg' in the list of variables 'vars'.
Solutions are split by degree, with the i-th element of the returned list having polynomials of degree 'i-1'.
If the \"KnownSolutions\" option is used to pass a list of known solutions, they will be excluded by the returned list.
"
CATSyzMerge::usage = "CATSyzMerge[a,b] merges two solutions returned by CATSyz."
CATUFGPolys::usage = "CATUFGPolys[propslist,loopmoms,ids,varsname] returns a list { U, F, G, vars} containing the Symanzik polymials U and F, G = U+F and a list of integration variables for Feynman, Schwinger or Lee-Pomeransky parametrizations of loop integrals."
CATBaikovPoly::usage = "CATBaikovPoly[dens,loopmoms,extmoms,replrules,z] returns {B,vars} where B is the Baikov polynomial defined by the list of denominators and vars is the corresponding list of integration variables of the form {z[1],z[2],...}."

CATInt::usage = "CATInt[type,{a1,...,an}] represents and integral or a rational integrand with exponents {a1,...,an}. \
Different types of integrals/integrands can be specified, identifying them via the first argument."

CATIntMellinDefaultWeight::usage = "CATMellinIdsDefaultWeight[CATInt[...]] returns a default weight for Mellin (Lee-Pomeransky or Schwinger) integrals."
CATUnorderedIntCases::usage = "CATUnorderedIntCases[expr] returns a list of CATInt[...] objects in an expression."
CATIntCases::usage = "CATIntCases[expr,weight] returns a list of CATInt[...] objects in an expression, sort by weight."

CATPolyDec::usage = "CATPolyDec[polys,rhs,vars,maxdeg] finds the polynomial coefficients of polys to obtain the polynomials in the list rhs.  If the solution is not found, either because maxdeg is too low or because the rhs is not in the ideals generated by polys, the corresponding entry of the solution is CATImpossible."

CATMellinIdToLPPrefactor::usage = "CATMellinIdToLPPrefactor[nloops,d,exponentslhs,exponentsrhs] yields the prefactor that needs to multiply the integral CATInt[family,exponentsrhs] on the r.h.s. of the reduction of the integral CATInt[family,exponentslhs] converting from Mellin to Lee-Pomeransky representation."
CATMellinToLPIds::usage = "CATMellinToLPIds[ids,nloops,d], where ids are template identities as returned by CATMellinIdsFromAnnihilators, converts ids into identities for the corresponding loop integrals in the Lee-Pomeransky representation, by adjusting the integral prefactors."
CATMellinToLPDiffOperators::usage = "CATMellinToLPDerivatives[derivatives,nloops,d] converts differential operators for Mellin integrals returned by CATMellinIdsFromDiffOperators into differential operators for loop integrals in the Lee-Pomeransky representation."

CATAnnihilator::usage = "CATAnnihilator[u,vars,maxdegree,maxorder] returns annihilators of the twist u."
CATAnnihilatorMerge::usage = "CATAnnihilatorMerge[a,b] merges two solutions returned by CATAnnihilator."

CATExponentList::usage = "CATExponentList[totaldeg,nvars] returns a list of lists of exponents in nvars variables of total degree totaldeg.  CATExponentList[totaldeg,nvars,range] only allows exponents in the set of integers range."
CATDerivativeList::usage = "CATDerivativeList[expr,vars,order] return a list of derivatives of expr with the specified order in the variables vars, which is consistent with the one used by CATAnnihilator.  The input order can also be a range."
CATDotDerivativeList::usage = "CATDerivativeList[expr,vars,order] return a sum whose i-th addend is a derivative of expr[[i]] with respect to the specified i-th differential operator of the specified order in the variables vars, which is consistent with the one used by CATAnnihilator.  The input order can also be a range."
CATDotIBPDerivativeList::usage = "CATDotIBPDerivativeList behaves as CATDotDerivativeList but derivatives of order o are multiplied by (-1)^o."

CATIdsFromAnnihilators::usage = "CATIdsFromAnnihilators[annihilators,vars,integrfct,toCAT] is a general purpose function that generates template identities from annihilators.  Its input are:
- annihilators: the annihilators as returned by CATAnnihilator
- vars: the integration variables
- integrfct: a function of a list of integer exponents returning the corresponding function phi (i.e. integrand without the twist)
- toCAT: a function that converts a function of vars into a linear combination of CATInt-s
The option \"ApplyFunction\"->applyfct can be use for an aribitrary transformation at the end. \
More specifically the replacement CATInt->applyfct[{a1,...,an},expr] will be made, where {a1,...,an} is a list of symbolic exponents \
for the seeds and expr is the identity before.
"
CATMellinIdsFromAnnihilators::usage = "CATMellinIdsFromAnnihilators[family,annihilators,vars] returns template identities from annihilators for Mellin integrals."
CATMonIdsFromAnnihilators::usage = "CATMonIdsFromAnnihilators[family,annihilators,vars] returns template identities from annihilators for integrals of monomials."
CATInvMonIdsFromAnnihilators::usage = "CATInvMonIdsFromAnnihilators[family,annihilators,vars] returns template identities from annihilators for integrals of inverse monomials (eg integrals in the Baikov representation)."
CATLPIdsFromAnnihilators::usage = "CATLPIdsFromAnnihilators[family,annihilators,vars,nloops,d] returns template identities from annihilators for loop integrals in the Lee-Pomeransky representation."
CATSchwingerIdsFromAnnihilators::usage = "CATSchwingerIdsFromAnnihilators[family,annihilators,vars] returns template identities from annihilators for loop integrals in the Schwinger representation."
CATDualInvMonIdsFromAnnihilators::usage = "CATDualInvMonIdsFromDiffOperators[family,annihilators,vars] returns template identities from annihilators operators for duals of Baikov-like integrals."

CATDiffOperator::usage = "CATDiffOperator[u,vars,diffparameters,maxdegree,maxorder] finds differential operators of the twist u wrt vars that are equivalent to differentiation wrt diffparameters."
CATIdsFromDiffOperators::usage = "CATIdsFromDiffOperators[operators,vars,integrfct,toCAT] returns template identities for the specified differential operators. \
The argument operators should be the return value of CATDiffOperator, while vars,integrfct,toCAT have the same meaning as in CATIdsFromAnnihilators."
CATMellinIdsFromDiffOperators::usage = "CATMellinIdsFromDiffOperators[family,diffoperators,vars] returns template identities from differential operators for Mellin integrals."
CATMonIdsFromDiffOperators::usage = "CATMonIdsFromDiffOperators[family,diffoperators,vars] returns template identities from differential operators for integrals of monomials."
CATInvMonIdsFromDiffOperators::usage = "CATInvMonIdsFromDiffOperators[family,diffoperators,vars] returns template identities from differential operators for integrals of inverse monomials (eg integrals in the Baikov representation)."
CATLPIdsFromDiffOperators::usage = "CATLPIdsFromDiffOperators[family,diffoperators,vars,nloops,d] returns template identities from differential operators for loop integrals in the Lee-Pomeransky representation."
CATSchwingerIdsFromDiffOperators::usage = "CATSchwingerIdsFromDiffOperators[family,diffoperators,vars] returns template identities from differential operators for loop integrals in the Schwinger representation."
CATDualInvMonIdsFromDiffOperators::usage = "CATDualInvMonIdsFromDiffOperators[family,diffoperators,vars] returns template identities from differential operators for duals of Baikov-like integrals."

CATGenerateSeeds::usage = "CATGenerateSeeds[sectai,{drmin,drmax},{smin,smax}] generates a list of seeds (i.e. a list of lists of exponents) satisfying a set of criteria:
- sectai: is a list of 1 and 0s identifying a sector (1 = positive exponent, 0 = non-positive exponent)
- {drmin,drmax}: min and max number of dots (number of dots = \"sum of positive exponents\" - \"number of positive exponents\")
- {smin,smax}:  min and max rank (= - \"sum of negative exponents).
"

CATTwist::usage = "CATTwist[twist,replacements] is used to represent a twist given as input to CATAnnihilator and CATDiffOperator."
CATLP::usage = "CATLP[g,d,z] returns the twist for Feynman integrals in Lee-Pomeransky representation."
CATSchwinger::usage = "CATSchwinger[u,f,d,z] returns the twist for Feynman integrals in Schwinger representation."
CATBaikov::usage = "CATBaikov[B,d,L,E,z] returns the twist for Feynman integrals in Baikov representation."
CATBaikovDual::usage = "CATBaikovDual[B,d,L,E,z] returns the twist for duals of Feynman integrals in Baikov representation."
CATMultiBaikov::usage = "CATMultiBaikov[b_List,exp_list,z] represents the twist Product[ b[[i]]^exp[[i]], {i,Length[b]}] in the integration variables z. \
CATMultiBaikov[b_List,exp_list,exparg_,z] is similar to CATMultiBaikov[b_List,exp_list,z] but multiplies the twist by the factor Exp[exparg], where exparg must be a polynomial in z.
"

CATFPoly::usage = "CATFPoly symbolically represents the F Symanzik polynomial (mostly for internal use)."
CATUPoly::usage = "CATUPoly symbolically represents the U Symanzik polynomial (mostly for internal use)."
CATGPoly::usage = "CATGPoly symbolically represents G=U+F, where F and U are Symanzik polynomials (mostly for internal use)."
CATBPoly::usage = "CATBPoly symbolically represents a Baikov polynomial (mostly for internal use)."

CATBaikovExponent::usage = "CATBaikovExponent[d,L,E] returns the exponent of the Baikov polynomial."

CATDualRegulated::usage = "Use `CATDualRegulated[family] = {...};` where the rhs is a list of 1s and 0s, specifies which denominators of the dual Baikov integrals of 'family' need to be regulated."

CATIntInvMonDefaultWeight::usage = "A default weight for Baikov-like integrals."
CATIntDualInvMonDefaultWeight::usage = "A default weight for duals of Baikov-like integrals."

CATVerbose::usage = "CATVerbose[True|False] switches on/off the verbosity. When set to true, information about the ongoing calculation is printed."
CATOrdering::usage = "CATOrdering[ordering], sets the type of ordering used by CALICO.  Available arguments are \"TermOverPosition\" (alias \"TOP\", used by default) and \"PositionOverTerm\" (alias \"POT\")."

CATImpossible::usage = "Symbol that signals an impossible polynomial decomposition or differential operator equation, for the specified order and maximum degree."

CATNode::usage = "CATNode[...] is reserved by the CALICO package for identifiers of nodes of FiniteFlow graphs."
CATCc::usage = "CATCc[node,j] is used by CALICO to represent the j-th element of node in a FiniteFlow graph."

CATApplyAnnihililators::usage = "CATApplyAnnihililators[ann,vars,expr] applies the annihilators ann in the variables vars (in the form returned by CATAnnihilator) to the expression expr."
CATApplyDiffOperators::usage = "CATApplyDiffOperators[diffop,params,vars,expr] applies the differential operators diffop in the variables vars (in the form returned by CATDiffOperator) to the expression expr."


CATMellinIntegrFct::usage="CATMellinIntegrFct is the integrfct argument to be used with CATIdsFromAnnihilators for Mellin integrals."
CATMellinToInt::usage="CATMellinToInt is the toCAT function to be used with CATIdsFromAnnihilators for Mellin integrals."
CATMellinIntApplyFct::usage="CATMellinIntApplyFct is the applyfct function to be used with CATIdsFromAnnihilators for Mellin integrals."
CATMonIntegrFct::usage="CATMonIntegrFct is the integrfct function to be used with CATIdsFromAnnihilators for integrals of monomials."
CATMonToInt::usage="CATMonToInt is the  toCAT function to be used with CATIdsFromAnnihilators for integrals of monomials."
CATInvMonIntegrFct::usage="CATInvMonIntegrFct is the integrfct function to be used with CATIdsFromAnnihilators for integrals of inverse monomials."
CATInvMonToInt::usage="CATInvMonToInt is the toCAT function to be used with CATIdsFromAnnihilators for Mellin integrals of inverse monomials."
CATSyz::badrec = "Returning earlier because the reconstruction failed. Using higher values of \"MaxRecPrimes\" or \"MaxRecDegree\" might fix the issue."
CATPolyDec::badrec = "The reconstruction failed. Using higher values of \"MaxRecPrimes\" or \"MaxRecDegree\" might fix the issue."


CATDotDerivativeList::baddim = "The dimension of the input list is incompatible with the one of the list of differential operators, for the specified order (the expected dimension was  `1`).";
CATBaikovPoly::invspdenoms = "Unable to invert for the scalar products in terms of loop denominators.";
CATBaikovPoly::redundantdenoms = "Loop denominators are not linearly independent.";
CATDualRegulated::undefined = "Undefined family `1` for dual integrals: you must define CATDualRegulated[`1`] first."
CATOrdering::badord = "The specified ordering is not supported."
CATSyz::ff2graph = "The \"Graph\" option is an experimental feature and currently requires using the exp branch of FiniteFlow."
CATSyz::graphnopar = "The \"Graph\" option requires to specify the list of parameters via the option \"Parameters\"."


Begin["`Private`"]


CATVerbose[flag_]:=(
  If[TrueQ[flag],
    print = Print;
    ,
    print = Null&;
  ];
);


CATInt[t_,b_]CATInt[t_,c_]^:=CATInt[t,b+c];
CATInt[t_,b_]^n_^:=CATInt[t,n b];


CATOrdering[ord_]:=Switch[
  ord,
  "TermOverPosition"|"TOP", syzordering = {Plus@@#[[1]],-Reverse[#[[1]]],#[[2]]}&;,
  "PositionOverTerm"|"POT", syzordering = {#[[2]],Plus@@#[[1]],-Reverse[#[[1]]]}&;,
  _, Message[CATOrdering::badord]; $Failed
];


If[!ValueQ[syzordering],
  CATOrdering["TermOverPosition"];
];


CATToHomogeneous[polys_List,vars_List,extravar_]:=Module[{rules,maxdd,ttt,hompolys},
  rules = FFCoefficientRules[#,vars]&/@polys;
  If[TrueQ[Equal@@((Plus@@(First[#]))&/@(Join@@rules))],
     {polys,vars},
     ttt = extravar;
     maxdd = Max[((Plus@@(First[#]))&/@(Join@@rules))];
     hompolys=FromCoefficientRules[#,Join[vars,{ttt}]]&/@((Join[#[[1]],{maxdd-(Plus@@#[[1]])}]->#[[2]]&/@#)&/@rules);
     {hompolys,Join[vars,{ttt}]}
  ]
];


CATToHomogeneousForceExtraVar[polys_List,vars_List,extravar_]:=Module[{rules,maxdd,ttt,hompolys},
  rules = FFCoefficientRules[#,vars]&/@polys;
  ttt = extravar;
  maxdd = Max[((Plus@@(First[#]))&/@(Join@@rules))];
  hompolys=FromCoefficientRules[#,Join[vars,{ttt}]]&/@((Join[#[[1]],{maxdd-(Plus@@#[[1]])}]->#[[2]]&/@#)&/@rules);
  {hompolys,maxdd}
];


(* The functions in this block have been taken and adapted from the FFIntRed package by T.P. *)

MonomialExp[total_,n_,range_]:=Join@@(DeleteDuplicates[Permutations[#]]& /@ IntegerPartitions[total,{n},range]);
MonomialExp[total_,n_]:=MonomialExp[total,n,Range[0,total]];

CombineMonomialExp[numidx_,numai_,denidx_,denai_]:=Module[
  {res},
  res = ConstantArray[0,Length[numai]+Length[denai]];
  res[[numidx]] = numai;
  res[[denidx]] = denai;
  res
];

CATGenerateSeeds[sectai_,{drmin_,drmax_},{smin_,smax_},filters_:{}]:=Module[{spsidx,denidx,spows,rpows,aipows,filter},
  spsidx = Flatten[Position[sectai,0]];
  denidx = Flatten[Position[sectai,1]];
  spows = -Join@@(MonomialExp[#,Length[spsidx]]&/@Range[smin,smax]);
  rpows = Join@@(MonomialExp[#,Length[denidx]]&/@Range[drmin,drmax]);
  aipows = (#+sectai)&/@(Join@@Table[CombineMonomialExp[spsidx,sp,denidx,rp],{sp,spows},{rp,rpows}]);
  filter = filters;
  If[!TrueQ[filter[[0]]==List], filter = {filter}];
  aipows = Select[aipows,(And@@(Table[filter[[i]][#],{i,Length[filter]}]))&];
  aipows
];


CATExponentList[total_,nvars_,range_]:=MonomialExp[total,nvars,range];
CATExponentList[total_,nvars_]:=MonomialExp[total,nvars];


(* copied from intersection code of GF and TP *)
NotSoRandomInteger[range_,n_:1,ii_:0]:=BlockRandom[
  SeedRandom[Abs[2147483623-ii]];
  Reverse[RandomInteger[range,n]]
];
NotSoRandomIntegerList[n_]:=BlockRandom[
  SeedRandom[Abs[2147483623]];
  Reverse[RandomInteger[{2^50,2^62},n]]
];
NotSoRandomIntegerList[n_,ii_]:=BlockRandom[
  SeedRandom[Abs[2147483623-ii]];
  Reverse[RandomInteger[{2^50,2^62},n]]
];


SygPolyRules[polys_List,vars_]:=SygPolyRules[#,vars]&/@polys;
SygPolyRules[poly_,vars_]:=FFCoefficientRules[poly,vars];
SygEqFromRules[f_,g_]:=Module[{ii,jj},
  (*Plus@@#&/@*)(Normal[GroupBy[
  Join@@Table[Join@@Outer[#1[[1]]+#2[[1]]-> {#2[[2]],#1[[2]]}&,f[[ii]],g[[ii]]],{ii,Length[f]}],
  First
]][[;;,2,;;,2]])
];


SyzRulesToPoly[syzrule_]:=Module[{coeffs,lcm,res},
  res = syzrule;
  coeffs = Together[DeleteDuplicates[Flatten[res[[;;,;;,2]]]]];
  If[Length[coeffs]>0,
    lcm = PolynomialLCM[Sequence@@(DeleteDuplicates[Denominator/@coeffs])];
    res[[;;,;;,2]] = Together[res[[;;,;;,2]] lcm];
    res
  ,
    res
  ]
]


SyzRulesRemoveZeroes[a_List]:=SyzRulesRemoveZeroes/@a;
SyzRulesRemoveZeroes[{a_List -> b_,c___}]:=DeleteCases[{a -> b,c},_->0];


fccEvalNode[g_,fcc_,in_,MONpolys_,params_,applyfun_]:=Module[
  {unique,tounique,ii,mons},
  unique = Union@@MONpolys[[;;,;;,2]];
  tounique = Association[{}];
  Do[tounique[unique[[ii]]] = ii;,{ii,Length[unique]}];
  mons = MONpolys;
  mons[[;;,;;,2]] = Map[tounique,mons[[;;,;;,2]],{2}];
  If[TrueQ[params=={}],
    FFAlgRatNumEval[g,fcc,unique];,
    FFAlgRatFunEval[g,fcc,{in},params,applyfun[unique]];
  ];
  mons
]


FilterAnsatz[numsyz_,vars_,deg_,cc_,ordering_,extccfilter_]:= Module[
               {ldeg,compldeg,calphas,gensols,numg,numsys,nmons,tocceq,versors,
                lccs,llearn,tmp,aa},
               tocceq[asyz_]:=Plus@@Join@@Table[
                 Map[cc[#[[1]],ii]#[[2]]&,asyz[[ii]]]
               ,{ii,Length[asyz]}];
               gensols = tocceq/@(Join@@Table[
                 If[Length[numsyz[[ldeg+1]]]>0,
                   compldeg = deg-ldeg;
                   calphas = MonomialExp[compldeg,Length[vars]];
                   Join@@Table[Map[(aa + #[[1]])->#[[2]]&,numsyz[[ldeg+1]],{3}],{aa,calphas}]
                 ,(*Else*)
                   {}
                 ]
               ,{ldeg,0,deg}]);
               If[Length[gensols]>0,

               FFNewGraph[numg];
               If[extccfilter===None,
                 lccs = Reverse[SortBy[DeleteDuplicates[Cases[gensols, _cc,Infinity]],ordering]];,
                 (* if an external filter is present, we eliminate with higher priority terms not passing it *)
                 lccs = Reverse[SortBy[DeleteDuplicates[Cases[gensols, _cc,Infinity]],{!extccfilter[##]&,ordering}]];
               ];
               FFAlgSparseSolver[numg,numsys,{},{},Thread[gensols==0],lccs];
               FFGraphOutput[numg,numsys];
               FFSolverSparseOutput[numg,numsys];
               llearn = FFSparseSolverLearn[numg,lccs];
               FFDeleteGraph[numg];
               "DepVars"/.llearn

               (*Else*),
               {}
               ]
            ];


CATHomLSSolve[g_,params_,fcc_,eqsin_,coeffs_,maxrecdeg_,maxrecprimes_,nthreads_,indeptozero_,customgraph_]:=Module[
  {eqs,res,cmap,ii,learn,nrec,lsin,ls,cleanupnodes},
  
  If[Length[eqsin]==0,
    Return[{}];
  ];
  
  cleanupnodes[]:=(
    FFDeleteNode[g,ls];
    FFMakeMutable[g,lsin];
    FFDeleteNode[g,lsin];
  );
  
  res = Catch[
  
  cmap = Association[{}];
  Do[cmap[coeffs[[ii]]]=ii;,{ii,Length[coeffs]}];
  cmap["rhs"] = Length[coeffs]+1;
  
  eqs = eqsin;
  eqs[[;;,;;,1]] = Map[cmap,eqs[[;;,;;,1]],{2}];
  eqs = SortBy[#,First]&/@eqs;
  If[customgraph,
    lsin = CATNode[FFPeekNewNodeId[g]];
  ];
  FFAlgTake[g,lsin,{fcc},{1,#}&/@Join@@eqs[[;;,;;,2]]];
  
  If[customgraph,
    ls = CATNode[FFPeekNewNodeId[g]];
  ];
  FFAlgNodeSparseSolver[g,ls,{lsin},eqs[[;;,;;,1]],coeffs];
  If[TrueQ[indeptozero && $FFVersion>=2],
    FFSolverOnlyNonHomogeneous[g,ls];
  ];
  FFSolverSparseOutput[g,ls];
  FFGraphOutput[g,ls];
  
  learn = FFSparseSolverLearn[g,coeffs];
  If[!TrueQ[learn[[0]]==List],Throw[learn]];
  FFSparseSolverMarkAndSweepEqs[g,ls];
  
  If[customgraph,
    res = FFSparseSolverSol[CATCc[ls,#]&/@Range[FFNParsOut[g,ls]],learn];
    If[FFNParsOut[g,ls]===0, cleanupnodes[];];
    Return[res];
  ];
  
  If[TrueQ[$FFVersion>=2],
    nrec = FFTakeUnique[g,"nrec",{ls}];
    FFGraphOutput[g,"nrec"];
  ];
  
  print["- rational reconstruction"];
  res = If[TrueQ[params == {}],
               FFReconstructNumeric[g, "MaxPrimes"->maxrecprimes],
               FFReconstructFunction[g,params, 
			                         "MaxDegree"->maxrecdeg,
			                         "MaxPrimes"->maxrecprimes,
			                         "NThreads"->nthreads]
        ];
  If[TrueQ[$FFVersion>=2],
    FFDeleteNode[g,"nrec"];
    FFMakeMutable[g,ls];
  ];
  
  If[!TrueQ[res[[0]]==List],Throw[res]];
  If[TrueQ[$FFVersion>=2],
    FFSparseSolverSol[res[[nrec]],learn]
    ,
    FFSparseSolverSol[res,learn]
  ]
  
  ];
  
  If[!customgraph || res[[0]] =!= List, cleanupnodes[]];
  
  If[res === FFImpossible, res = CATImpossible];
  res
];


If[TrueQ[$FFVersion >= 2],
  checkff2graph = True&;,
  checkff2graph = (Message[CATSyz::ff2graph]; False)&;
];


ccevals[expr_,graph_,numericpt_]:=Module[
  {catccs,nodes},
  catccs = SortBy[Union[Cases[{expr},_CATCc,Infinity]],First];
  nodes = Union[catccs[[;;,1]]];
  Join@@Table[
    FFGraphOutput[graph,nn];
    Thread[(CATCc[nn,#]&/@Range[FFNParsOut[graph,nn]])->FFGraphEvaluate[graph,numericpt]]
  ,{nn,nodes}]
];


Options[CATHomSyz]:={"MinDegree"->0, "Parameters"->Automatic, "MaxRecDegree"->Automatic, "MaxRecPrimes"->Automatic,
  "KnownSolutions"->None, "PolynomialInParameters"->True, "NThreads"->Automatic, "ApplyFunction"->Identity,
  "Graph"->None, "InputNode"->Automatic, "FilterAnsatz"->None
};
CATHomSyz[ polys_ , vars_ , maxdeg_, OptionsPattern[]]:=Module[
{g,mindeg,MONpolys,deg,alphas,ccalphas,cc,ansatz,alphanasatz,FFMsyzeqs,
 coeffs,ordering,eqs,sols,solvedansatz,indepccs,alldirections,subs,syz,numericpt,
 filteredoutccs,numsyz,params,knownsols,ii,maybetopoly,MON,inputpt,
 customgraph,in,fcc,catccnums={},one=1,anysolution=False,extfilter,extccfilter},

		print["- setting up homogeneous syzygy solver"];
		params = OptionValue["Parameters"];
		customgraph = OptionValue["Graph"] =!= None;
		If[customgraph && !checkff2graph[], Return[$Failed]];
		If[TrueQ[params==Automatic],
		  params = Sort[Complement[Variables[polys],vars]];
		  If[Length[params]>1 && customgraph,
		    Message[CATSyz::graphnopar]; Return[$Failed];
		  ];
		];

		mindeg = OptionValue["MinDegree"];
		
	    If[customgraph,
	      g = OptionValue["Graph"];
		  in = OptionValue["InputNode"];
		  If[in === Automatic && Length[params] != 0, in = FFGraphInputNode[g];];
		  If[!FFAlgQ[g,CATNode[-1]], FFAlgRatNumEval[g,CATNode[-1],{1}]];
		  one = CATCc[CATNode[-1],1];
		  fcc = CATNode[FFPeekNewNodeId[g]];
		];
		
		If[!customgraph,
		  numericpt = Dispatch[Thread[params->NotSoRandomIntegerList[Length[params]]]];
		,
		  inputpt = NotSoRandomIntegerList[FFNParsOut[g,FFGraphInputNode[g]]];
		  FFGraphOutput[g,in];
		  numericpt = Dispatch[Thread[params->FFGraphEvaluate[g,inputpt]]];
		];
		
		If[!customgraph,
		  FFNewGraph[g,in,params];
		];
		MONpolys = fccEvalNode[g,fcc,in,SygPolyRules[polys,vars],params,OptionValue["ApplyFunction"]];
		
		(* From lower to higher in rev.deg.lex.
			ordering first by monomials & then by index k*)
        ordering=syzordering;
        (*building the fj ansatz*)
        syz = {}&/@Range[maxdeg+1];
        numsyz = {}&/@Range[maxdeg+1];

        (* add known solutions to numerical solutions *)
        knownsols = OptionValue["KnownSolutions"];
        If[customgraph, catccnums = Dispatch[ccevals[knownsols, g, inputpt]]];
        If[TrueQ[knownsols[[0]]==List],
          knownsols = SygPolyRules[knownsols /. catccnums /.numericpt,vars];
        ];
        Do[numsyz[[ii]] = knownsols[[ii]]; ,{ii,Min[Length[knownsols],Length[numsyz]]}];

        If[TrueQ[!customgraph && OptionValue["PolynomialInParameters"]],
          maybetopoly = SyzRulesToPoly,
          maybetopoly = Identity
        ];
        
        extfilter = OptionValue["FilterAnsatz"];
        extccfilter = None;

		Do[
		    print["- degree ",deg];
		    (* filtering *)
		    If[!(extfilter === None), extccfilter = (extfilter[deg,#[[2]],#[[1]]]&); ];
            filteredoutccs = FilterAnsatz[numsyz,vars,deg,cc,ordering,extccfilter];

            alphas =  MON/@MonomialExp[deg,Length[vars]];
			ccalphas = cc@@#&/@alphas;
			alphanasatz = Inner[#1[[1]]->#2 &,alphas, ccalphas, List];

			ansatz = SyzRulesRemoveZeroes[Table[ alphanasatz/.cc->(cc[#,k]&),{k,Length[polys]}] /. Dispatch[#->0&/@filteredoutccs]];
			If[!(extfilter === None),
			  coeffs = DeleteDuplicates[Cases[ansatz,_cc,Infinity]];
			  ansatz = SyzRulesRemoveZeroes[ ansatz /. Dispatch[#->0&/@Select[coeffs,!TrueQ[extccfilter[#]]&]] ];
			];
			eqs = SygEqFromRules[MONpolys,ansatz];

			(*solving eqs*)
			coeffs = SortBy[DeleteDuplicates[Cases[eqs, _cc,Infinity]],ordering];
			print["- linear solver"];
			sols = CATHomLSSolve[g,params,fcc,eqs,coeffs,
			                     OptionValue["MaxRecDegree"], OptionValue["MaxRecPrimes"],
			                     OptionValue["NThreads"], False, customgraph];
			If[!TrueQ[sols[[0]]==List],
			  Message[CATSyz::badrec];
			  Break[];
			];

			(*finding generators*)
			(*independent*)
			print["- building solutions"];
			solvedansatz = Collect[ansatz/.Dispatch[sols],_cc];
			(*quali coeff sono nell ansatz risolta*)
			indepccs = SortBy[DeleteDuplicates[Cases[solvedansatz,_cc,Infinity]],ordering];
			If[customgraph,
			  solvedansatz = Map[If[FreeQ[#,_CATCc],#[[1]]->#[[2]]one, #]&, solvedansatz, {2}];
			];
			If[TrueQ[Length[indepccs]==0],
			  syz[[deg+1]]={};
			(*Else*),
			  anysolution = True;
			  alldirections = UnitVector[Length[indepccs],#]&/@Range[Length[indepccs]];
			  subs = Dispatch/@Table[Thread[indepccs->alldirections[[ii]]],{ii,Length[alldirections]}];
			  syz[[deg+1]] = maybetopoly/@SyzRulesRemoveZeroes[solvedansatz/.subs];
			];
			If[customgraph, catccnums = Dispatch[ccevals[syz[[deg+1]], g, inputpt]]];
			numsyz[[deg+1]] = DeleteDuplicates[Join[numsyz[[deg+1]], syz[[deg+1]] /. catccnums /. numericpt]];
			(*vogliamo fare tante soluzioni in cui tutti i cc indipendenti sono 0 tranne 1*)
         ,{deg,mindeg,maxdeg}];
     If[customgraph && !anysolution, FFMakeMutable[g,fcc]; FFDeleteNode[g,fcc];];
     If[!customgraph, FFDeleteGraph[g];];
     Map[FromCoefficientRules[#,vars]&,syz,{3}]
]


Options[CATHomPolyDec]:={"Parameters"->Automatic, "MaxRecDegree"->Automatic, "MaxRecPrimes"->Automatic,
  "NThreads"->Automatic, "KnownSolutions"->None, "ApplyFunction"->Identity,
  "Graph"->None, "InputNode"->Automatic, "FilterAnsatz"->None
};
CATHomPolyDec[polys_ , rhs_, vars_, OptionsPattern[]]:=Module[
{g,MONpolys,MONrhs,degpolys,degrhs,deg,alphas,ccalphas,cc,ccr,ansatz,alphanasatz,FFMsyzeqs,
 coeffs,coeffsr,ordering,eqs,sols,solvedansatz,indepccs,alldirections,subs,numericpt,
 filteredoutccs,numsyz,params,knownsols,ii,ansatzrhs,MON,foundsols,syzsol,inputpt,
 customgraph,in,fcc,catccnums={},anysolution=False,extfilter,extccfilter},

		print["- setting up homogeneous poly decomposition with ",Length[rhs]," r.h.s"];
		params = OptionValue["Parameters"];
		customgraph = OptionValue["Graph"] =!= None;
		If[customgraph && !checkff2graph[], Return[$Failed]];
		If[TrueQ[params==Automatic],
		  params = Sort[Complement[Variables[{polys,rhs}],vars]];
		  If[Length[params]>1 && customgraph,
		    Message[CATSyz::graphnopar]; Return[$Failed];
		  ];
		];
		
		If[customgraph,
		  g = OptionValue["Graph"];
		  in = OptionValue["InputNode"];
		  If[in === Automatic && Length[params] != 0, in = FFGraphInputNode[g];];
		  If[!FFAlgQ[g,CATNode[-1]], FFAlgRatNumEval[g,CATNode[-1],{1}]];
		  fcc = CATNode[FFPeekNewNodeId[g]];
		];
		
		If[!customgraph,
		  numericpt = Dispatch[Thread[params->NotSoRandomIntegerList[Length[params]]]];
		,
		  inputpt = NotSoRandomIntegerList[FFNParsOut[g,FFGraphInputNode[g]]];
		  FFGraphOutput[g,in];
		  numericpt = Dispatch[Thread[params->FFGraphEvaluate[g,inputpt]]];
		];

		If[!customgraph,
		  FFNewGraph[g,in,params];
		];
		MONpolys = fccEvalNode[g,fcc,in,SygPolyRules[Join[polys,rhs],vars],params,OptionValue["ApplyFunction"]];
		MONrhs = MONpolys[[Length[polys]+1;;]];
		MONpolys = MONpolys[[1;;Length[polys]]];
		
		degpolys = Plus@@MONpolys[[1,1,1]];
		degrhs = Plus@@MONrhs[[1,1,1]];

		deg = degrhs - degpolys;
		print["- degree ",deg];

		If[!TrueQ[deg>0],
		  Return[ConstantArray[CATImpossible,Length[rhs]]];
		];
		(* From lower to higher in rev.deg.lex.
			ordering first by monomials & then by index k*)
         ordering=syzordering;
        (*building the fj ansatz*)
        numsyz = {}&/@Range[deg+1];

        (* add known solutions to numerical solutions *)
        knownsols = OptionValue["KnownSolutions"];
        If[customgraph, catccnums = Dispatch[ccevals[knownsols, g, inputpt]]];
        If[TrueQ[knownsols[[0]]==List],
          knownsols = SygPolyRules[knownsols /. catccnums /.numericpt,vars];
        ];
        Do[numsyz[[ii]] = knownsols[[ii]]; ,{ii,Min[Length[knownsols],Length[numsyz]]}];
        
        extfilter = OptionValue["FilterAnsatz"];
        extccfilter = None;

		Block[{},
		    (* filtering *)
		    If[!(extfilter === None), extccfilter = (extfilter[deg,#[[2]],#[[1]]]&); ];
            filteredoutccs = FilterAnsatz[numsyz,vars,deg,cc,ordering,extccfilter];

            alphas =  MON/@MonomialExp[deg,Length[vars]];
			ccalphas = cc@@#&/@alphas;
			alphanasatz = Inner[#1[[1]]->#2 &,alphas, ccalphas, List];

			ansatz = SyzRulesRemoveZeroes[Table[ alphanasatz/.cc->(cc[#,k]&),{k,Length[polys]}] /. Dispatch[#->0&/@filteredoutccs]];
			If[!(extccfilter === None),
			  coeffs = DeleteDuplicates[Cases[ansatz,_cc,Infinity]];
			  ansatz = SyzRulesRemoveZeroes[ ansatz /. Dispatch[#->0&/@Select[coeffs,!TrueQ[extccfilter[#]]&]] ];
			];

			syzsol = Table[
			ansatzrhs = {{ConstantArray[0,Length[vars]]->"rhs"}};
			eqs = SygEqFromRules[Join[MONpolys,{MONrhs[[ii]]}],Join[ansatz,ansatzrhs]];

			(*solving eqs*)
			coeffs = SortBy[DeleteDuplicates[Cases[eqs, _cc,Infinity]],ordering];
			print["- linear solver ",ii,"/",Length[rhs]];
			sols = CATHomLSSolve[g,params,fcc,eqs,coeffs,
			                     OptionValue["MaxRecDegree"], OptionValue["MaxRecPrimes"],
			                     OptionValue["NThreads"], True, customgraph];
			If[!TrueQ[sols[[0]]==List || sols==CATImpossible],
			  Message[CATPolyDec::badrec];
			];
			
			If[!TrueQ[sols[[0]]==List],

			  CATImpossible,

			  (* Else - solution found*)
			  print["- building solutions"];
			  anysolution=True;
			  sols[[;;,2]] = sols[[;;,2]] /. cc->(0&);
			  solvedansatz = Collect[ansatz/.Dispatch[sols] /. cc->(0&),_cc];
			  FromCoefficientRules[#,vars]&/@SyzRulesRemoveZeroes[solvedansatz]
			]
	        ,{ii,Length[rhs]}];
	 ];
	 If[customgraph && !anysolution,
	   FFMakeMutable[g,fcc];
	   FFDeleteNode[g,fcc];
     ];
	 If[!customgraph, FFDeleteGraph[g];];
     syzsol
]


Options[CATSyz]={"MinDegree"->0, "Parameters"->Automatic, "MaxRecDegree"->Automatic, "MaxRecPrimes"->Automatic,
  "NThreads"->Automatic, "KnownSolutions"->None, "PolynomialInParameters"->True, "ApplyFunction"->Identity,
  "Graph"->None, "InputNode"->Automatic, "FilterAnsatz"->None
};
CATSyz[ polys_ , vars_ , maxdeg_, OptionsPattern[]]:=Module[
  {hpolys,hvars,auxvar,knownsols,filterin,filter},
  print["CATSyz:"];
  {hpolys,hvars} = CATToHomogeneous[polys,vars,auxvar];
  knownsols = OptionValue["KnownSolutions"];
  filter = filterin = OptionValue["FilterAnsatz"];
  If[TrueQ[Length[hvars]>Length[vars] && Length[knownsols]>0],
    knownsols = Expand[(auxvar^# & /@ Range[0,Length[knownsols]-1]) knownsols /. Dispatch[Thread[vars -> vars/auxvar]],(Alternatives@@vars)|auxvar];
  ];
  If[TrueQ[Length[hvars]>Length[vars] && !(filter === None)],
    filter = filterin[#1,#2,#3[[;;-2]]]&;
  ];
  CATHomSyz[hpolys,hvars,maxdeg,
    "MinDegree"->OptionValue["MinDegree"],
    "Parameters"->OptionValue["Parameters"],
    "MaxRecDegree"->OptionValue["MaxRecDegree"],
    "MaxRecPrimes"->OptionValue["MaxRecPrimes"],
    "NThreads"->OptionValue["NThreads"],
    "KnownSolutions"->knownsols,
    "PolynomialInParameters"->OptionValue["PolynomialInParameters"],
    "ApplyFunction"->OptionValue["ApplyFunction"],
    "Graph"->OptionValue["Graph"],
    "InputNode"->OptionValue["InputNode"],
    "FilterAnsatz"->filter
  ] /. auxvar->1
];


CATSyzMerge[a_,b_]:=Module[
{bb,ii},
If[Length[a]<Length[b], Return[CATSyzMerge[b,a]]];
bb = b;
While[Length[bb]<Length[a], AppendTo[bb,{}]];
Table[
Join[a[[ii]],bb[[ii]]]
,{ii,Length[a]}]
]


Options[CATPolyDec]={"MinDegree"->0, "Parameters"->Automatic, "MaxRecDegree"->Automatic, "MaxRecPrimes"->Automatic,
  "NThreads"->Automatic, "KnownSyzygySolutions"->None, "ApplyFunction"->Identity,
  "Graph"->None, "InputNode"->Automatic, "FilterAnsatz"->None
};
CATPolyDec[ polys_List , rhs_List, vars_List , maxdeg_, OptionsPattern[]]:=Module[
  {hpolys,hvars,hrhs,auxvar,knownsols,polydeg,rhsdeg,mindeg,subset,sol,filter,filterin},
  print["CATPolyDec:"];
  {hpolys,polydeg} = CATToHomogeneousForceExtraVar[polys,vars,auxvar];
  {hrhs,rhsdeg} = CATToHomogeneousForceExtraVar[rhs,vars,auxvar];
  hvars = Join[vars,{auxvar}];
  If[rhsdeg<polydeg,
    hrhs = Expand[hrhs auxvar^(polydeg-rhsdeg),Alternatives@@hvars];
  ];
  mindeg = Max[OptionValue["MinDegree"],rhsdeg-polydeg];
  knownsols = OptionValue["KnownSyzygySolutions"];
  filter = filterin = OptionValue["FilterAnsatz"];
  If[TrueQ[Length[hvars]>Length[vars] && Length[knownsols]>0],
    knownsols = Expand[(auxvar^# & /@ Range[0,Length[knownsols]-1]) knownsols /. Dispatch[Thread[vars -> vars/auxvar]],(Alternatives@@vars)|auxvar];
  ];
  If[TrueQ[Length[hvars]>Length[vars] && !(filter === None)],
    filter = filterin[#1,#2,#3[[;;-2]]]&;
  ];

  subset = Range[Length[rhs]]; (* subset of rhs that hasn't been solved yet *)
  sol = ConstantArray[CATImpossible,Length[rhs]];
  Do[
  If[deg>mindeg,
    (* we increase the degree by multiplying the rhs by the aux. variable *)
    hrhs[[subset]] = Expand[hrhs[[subset]] auxvar, Alternatives@@hvars];
  ];
  sol[[subset]] = CATHomPolyDec[hpolys,hrhs[[subset]],hvars,
    "Parameters"->OptionValue["Parameters"],
    "MaxRecDegree"->OptionValue["MaxRecDegree"],
    "MaxRecPrimes"->OptionValue["MaxRecPrimes"],
    "NThreads"->OptionValue["NThreads"],
    "KnownSolutions"->knownsols,
    "ApplyFunction"->OptionValue["ApplyFunction"],
    "Graph"->OptionValue["Graph"],
    "InputNode"->OptionValue["InputNode"],
    "FilterAnsatz"->filter
  ];
  If[!MemberQ[sol,CATImpossible],
    Break[];
  ];
  subset = Flatten[Position[sol,CATImpossible,1]];
  ,{deg,mindeg,maxdeg}];
  sol /. auxvar->1
];


(* begin: more general routines *)


(* ansatz of o-th order annihilator *)
genericccsol[cc_,o_,vars_]:=Join[{cc[{}]@@vars},Join@@Table[cc[ords]@@(vars),{ii,1,o},{ords,MonomialExp[ii,Length[vars]]}]];


(* definition of syzygy eq from o-th order annihilator *)
CATAnnihilatorToSyz[u_,vars_,o_,subst_]:=Module[{eq,cc,ccs,syz,dens,fact,ann,ords},
  ann = (cc[{}]@@vars) (u)+ Sum[
                               Sum[cc[ords]@@(vars)D[u,Sequence@@Inner[List,vars,ords,List]],{ords,MonomialExp[ii,Length[vars]]}]
                            ,{ii,1,o}];
  eq = Expand[Collect[1/(u)ann,_cc],_cc];
  ccs = genericccsol[cc,o,vars];
  syz = Together[Coefficient[eq,ccs]];
  dens = Denominator[syz];
  fact = PolynomialLCM@@dens;
  syz fact /. subst // Together
];


(* definition of poly dec. eq of o-th order diff operator *)
CATDiffToPolyDec[u_,vars_,diffparameters_List,o_,subst_]:=Module[{eq,cc,ccs,syz,dens,fact,ann,ords,rhs},
  ann = (cc[{}]@@vars) (u)+ Sum[
                               Sum[cc[ords]@@(vars)D[u,Sequence@@Inner[List,vars,ords,List]],{ords,MonomialExp[ii,Length[vars]]}]
                            ,{ii,1,o}];
  rhs = Together[1/(u)(D[u,#]&/@diffparameters)];
  eq = Expand[Collect[1/(u)ann,_cc],_cc];
  ccs = genericccsol[cc,o,vars];
  syz = Together[Coefficient[eq,ccs]];
  dens = Join[Denominator[syz],Denominator[rhs]];
  fact = PolynomialLCM@@dens;
  {syz fact, rhs fact} /.subst // Together
];


(* definition of syzygy eq from o-th order annihilator *)
CATAnnihilatorToSyz[CATTwist[u_,repl_],vars_,o_,subst_]:=Module[{eq,cc,ccs,syz,dens,fact,ann,ords},
  ann = (cc[{}]@@vars) (u)+ Sum[
                               Sum[cc[ords]@@(vars)D[u,Sequence@@Inner[List,vars,ords,List]],{ords,MonomialExp[ii,Length[vars]]}]
                            ,{ii,1,o}];
  eq = Expand[Collect[1/(u)ann,_cc],_cc];
  ccs = genericccsol[cc,o,vars];
  syz = Together[Coefficient[eq,ccs]];
  dens = Denominator[syz];
  fact = PolynomialLCM@@dens;
  Expand[Together[syz fact] /. repl /. subst]
];


(* definition of poly dec. eq of o-th order diff operator *)
CATDiffToPolyDec[CATTwist[u_,repl_],vars_,diffparameters_List,o_,subst_]:=Module[{eq,cc,ccs,syz,dens,fact,ann,ords,rhs},
  ann = (cc[{}]@@vars) (u)+ Sum[
                               Sum[cc[ords]@@(vars)D[u,Sequence@@Inner[List,vars,ords,List]],{ords,MonomialExp[ii,Length[vars]]}]
                            ,{ii,1,o}];
  rhs = Together[1/(u)(D[u,#]&/@diffparameters)];
  eq = Expand[Collect[1/(u)ann,_cc],_cc];
  ccs = genericccsol[cc,o,vars];
  syz = Together[Coefficient[eq,ccs]];
  dens = Join[Denominator[syz],Denominator[rhs]];
  fact = PolynomialLCM@@dens;
  Expand[Together[{syz fact, rhs fact}]/. repl /. subst]
];


CATAnnihilatorDerivatives[vars_List,o_]:=Join[{ConstantArray[0,Length[vars]]},genericccsol[CATdummycc,o,vars][[2;;,0,1]]];


(* generate a higher order annihilator from a lower order one *)
higherfromlowerord[extrao_,extrad_,ann_,o_,vars_]:=Module[{u,uvec,newuvec},
  uvec = Join[{u@@vars},Join@@Table[D[u@@vars,Sequence@@Inner[List,vars,ords,List]],{ii,1,o},{ords,MonomialExp[ii,Length[vars]]}]];
  newuvec = Join[{u@@vars},Join@@Table[D[u@@vars,Sequence@@Inner[List,vars,ords,List]],{ii,1,o+extrao},{ords,MonomialExp[ii,Length[vars]]}]];
  Coefficient[Expand[D[ann . uvec,Sequence@@Inner[List,vars,extrad,List]]],newuvec]
]


Options[CATAnnihilator]=Join[Options[CATSyz],{"MinOrder"->1,"Substitutions"->{}}];
CATAnnihilator[u_,vars_,maxdegree_,maxorder_,opt:OptionsPattern[]]:=Module[
{c0,ci,annihilatorpolys,result,extknown,known,newknown,newannfromlower,filter,syzfilter,ordops,ords,ii},
print["CATAnnihilator:"];
extknown = OptionValue["KnownSolutions"];
known = ConstantArray[{},maxorder];
Scan[(known[[#]] = extknown[[#]])&, Range[Min[Length[extknown],maxorder]]];
result = {}&/@Range[maxorder];

(* generate new annihilators from lower orders *)
newannfromlower[mino_,maxo_]:=Module[{extrads,ann,annwdeg,newann},
  If[mino>maxo || maxo<=1, Return[]];
  Do[
    extrads = Join[MonomialExp[0,Length[vars]],MonomialExp[1,Length[vars]]];
    newann = Table[
        Join@@Table[ higherfromlowerord[1,#,ann,o-1,vars]&/@extrads,{ann,annwdeg}]
    ,{annwdeg,known[[o-1]]}];
    known[[o]] = CATSyzMerge[known[[o]],newann];
,{o,mino,maxo}];
];
newannfromlower[2,OptionValue["MinOrder"]-1];

filter = OptionValue["FilterAnsatz"];
syzfilter = None;

Do[
  (* find o-th order annihilators from lower orders, to exclude them from the solutions *)
  print["- order ",o];
  newannfromlower[o,o];
  print["- convert annihilator to syzygy equations"];
  annihilatorpolys = CATAnnihilatorToSyz[u,vars,o,OptionValue["Substitutions"]];
  If[!(filter === None),
   ordops = Join[{ConstantArray[0,Length[vars]]},Join@@Table[ords,{ii,1,o},{ords,MonomialExp[ii,Length[vars]]}]];
   syzfilter = (filter[o,ordops[[#2]],#1,#3]&);
  ];
  print["- compute syzygy"];
  result[[o]] = CATSyz[annihilatorpolys,vars,maxdegree,
                     Sequence@@FilterRules[FilterRules[{opt},Except["KnownSolutions"|"FilterAnsatz"]],Options[CATSyz]],
                     "KnownSolutions"->known[[o]],
                     "FilterAnsatz"->syzfilter];
  known[[o]] = CATSyzMerge[known[[o]],result[[o]]];
,{o,OptionValue["MinOrder"],maxorder}];
result
]


CATAnnihilatorMerge[a_,b_]:=Module[
{bb,ii},
If[Length[a]<Length[b], Return[CATAnnihilatorMerge[b,a]]];
bb = b;
While[Length[bb]<Length[a], AppendTo[bb,{}]];
Table[
CATSyzMerge[a[[ii]],bb[[ii]]]
,{ii,Length[a]}]
]


Options[CATDiffOperator]=Join[FilterRules[Options[CATPolyDec],Except["KnownSyzygySolutions"]],
                              {"MinOrder"->1,"Substitutions"->{},"KnownAnnihilatorSolutions"->None}];
CATDiffOperator[u_,vars_,diffparameters_,maxdegree_,maxorder_,opt:OptionsPattern[]]:=Module[
{annihilatorpolys,rhs,result,extknown,known,newknown,newannfromlower,return,subset,ii,jj,fixres,subst,
 filter,syzfilter,ordops,ords},
print["CATDiffOperator:"];
extknown = OptionValue["KnownAnnihilatorSolutions"];
known = ConstantArray[{},maxorder];
Scan[(known[[#]] = extknown[[#]])&, Range[Min[Length[extknown],maxorder]]];
result = (0->CATImpossible)&/@Range[Length[diffparameters]];

(* generate new annihilators from lower orders *)
newannfromlower[mino_,maxo_]:=Module[{extrads,ann,annwdeg,newann},
  If[mino>maxo || maxo<=1, Return[]];
  Do[
    extrads = Join[MonomialExp[0,Length[vars]],MonomialExp[1,Length[vars]]];
    newann = Table[
        Join@@Table[ higherfromlowerord[1,#,ann,o-1,vars]&/@extrads,{ann,annwdeg}]
    ,{annwdeg,known[[o-1]]}];
    known[[o]] = CATSyzMerge[known[[o]],newann];
,{o,mino,maxo}];
];
newannfromlower[2,OptionValue["MinOrder"]-1];

filter = OptionValue["FilterAnsatz"];
syzfilter = None;

Do[
  print["- order ",o];
  (* find o-th order annihilators from lower orders, to exclude them from the solutions *)
  subset = Select[Range[Length[diffparameters]], MatchQ[result[[#]],_->CATImpossible]&];
  If[TrueQ[Length[subset]==0],
    Break[];
  ];
  newannfromlower[o,o];
  print["- convert to polynomial decomposition"];
  {annihilatorpolys,rhs} = CATDiffToPolyDec[u,vars,diffparameters[[subset]],o,OptionValue["Substitutions"]];
  If[!(filter === None),
   ordops = Join[{ConstantArray[0,Length[vars]]},Join@@Table[ords,{ii,1,o},{ords,MonomialExp[ii,Length[vars]]}]];
   syzfilter = (filter[o,ordops[[#2]],#1,#3]&);
  ];
  print["- compute decomposition"];
  result[[subset]] = Thread[
           o->CATPolyDec[annihilatorpolys,rhs,vars,maxdegree,
                        Sequence@@FilterRules[FilterRules[{opt},Except["KnownAnnihilatorSolutions"|"FilterAnsatz"]],Options[CATPolyDec]],
                        "KnownSyzygySolutions"->known[[o]],
                        "FilterAnsatz"->syzfilter]
  ];
,{o,OptionValue["MinOrder"],maxorder}];

fixres[a_]:=a;
fixres[_->CATImpossible]=CATImpossible;
fixres/@result
];


CATDerivativeList[expr_,vars_,order_]:=Table[D[expr,Sequence@@Inner[List,vars,ords,List]],{ords,MonomialExp[order,Length[vars]]}];
CATDerivativeList[expr_,vars_,order_List]:=Join@@(CATDerivativeList[expr,vars,#]&/@order);


CATDotDerivativeListImplem[expr_List,vars_,order_List,sign_]:=Module[
  {ords,ii},
  ords = Join@@(MonomialExp[#,Length[vars]]&/@order);
  If[!TrueQ[Length[ords]==Length[expr]],
    Message[CATDotDerivativeList::baddim,Length[ords]];
    Return[$Failed];
  ];
  Sum[sign^(Plus@@ords[[ii]]) D[expr[[ii]],Sequence@@Inner[List,vars,ords[[ii]],List]],{ii,Length[ords]}]
];
CATDotDerivativeListImplem[expr_List,vars_,order_,sign_]:=CATDotDerivativeListImplem[expr,vars,{order},sign];


CATDotDerivativeList[expr_List,vars_,order_]:=CATDotDerivativeListImplem[expr,vars,order,1];


CATDotIBPDerivativeList[expr_List,vars_,order_]:=CATDotDerivativeListImplem[expr,vars,order,-1];


(* end: more general routines *)


(*function for U,G,F polynomials*)
CATUFGPolys[propslist_List,loopmoms_List,ids_List,varsname_]:=Module[
 {xDens, l, nvars, vars, M(*, kij, mij*), i, j, U, V(*, vi, ki*), F,G, loop2zero,Minvtilde},

		l=Length[loopmoms];
		nvars=Length[propslist];
		vars=varsname/@Range[nvars];

		xDens=Total[Table[Expand[propslist[[i, 1]]^2 -propslist[[i,2]]] * vars[[i]], {i, Length[propslist]}]];
		M=ConstantArray[0,{l,l}];

		Do[
			(*kij=loopmoms[[i]]*loopmoms[[j]];
			mij=Coefficient[xDens,kij];
						If[i==j,
							M[[i,j]]=mij,
							M[[i,j]]=mij/2;
							M[[j,i]]=mij/2;
							]*)
			 M[[i,j]]=M[[j,i]]=1/2 D[D[xDens,loopmoms[[i]]],loopmoms[[j]]];,
			{i,1,l},{j,i,l}];

		loop2zero = #->0&/@loopmoms;
		V = Table[
			1/2 D[xDens,loopmoms[[i]]]/.loop2zero,
			{i,1,l}];

		j=xDens/.loop2zero;

		U=Expand[Det[M]];
		Minvtilde = Together[U Inverse[M]];
		F=Expand[Expand[(Transpose[V] . Minvtilde . V-U j)]/.ids];
		G=U+F;

{U,F,G,vars}
]


CATMellinIntegrFct[vars_]:=Evaluate[Product[vars[[ii]]^(Slot[ii]-1),{ii,Length[vars]}]]&;
CATMellinToInt[type_,vars_]:=(CATInt[type,ConstantArray[1,Length[vars]]]# /. Dispatch[Table[vars[[ii]]->CATInt[type,UnitVector[Length[vars],ii]],{ii,Length[vars]}]])&;
CATMellinIntApplyFct[a_,expr_]:=expr /. CATInt->((Times@@FunctionExpand[(Gamma/@#2)/(Gamma/@a)])(CATInt[##])&);

CATMonIntegrFct[vars_]:=Evaluate[Product[vars[[ii]]^(Slot[ii]),{ii,Length[vars]}]]&;
CATMonToInt[type_,vars_]:=(CATInt[type,ConstantArray[0,Length[vars]]]# /. Dispatch[Table[vars[[ii]]->CATInt[type,UnitVector[Length[vars],ii]],{ii,Length[vars]}]])&;

CATInvMonIntegrFct[vars_]:=Evaluate[Product[vars[[ii]]^(-Slot[ii]),{ii,Length[vars]}]]&;
CATInvMonToInt[type_,vars_]:=(CATInt[type,ConstantArray[0,Length[vars]]]# /. Dispatch[Table[vars[[ii]]->CATInt[type,-UnitVector[Length[vars],ii]],{ii,Length[vars]}]])&;


CATMellinIdsFromAnnihilators[type_,annihilators_,vars_]:=CATIdsFromAnnihilators[annihilators,vars,CATMellinIntegrFct[vars],CATMellinToInt[type,vars],"ApplyFunction"->CATMellinIntApplyFct];
CATMonIdsFromAnnihilators[type_,annihilators_,vars_]:=CATIdsFromAnnihilators[annihilators,vars,CATMonIntegrFct[vars],CATMonToInt[type,vars]];
CATInvMonIdsFromAnnihilators[type_,annihilators_,vars_]:=CATIdsFromAnnihilators[annihilators,vars,CATInvMonIntegrFct[vars],CATInvMonToInt[type,vars]];


Options[CATIdsFromAnnihilators]:={"ApplyFunction"->(#2&)};
CATIdsFromAnnihilators[annihilators_,vars_,integrfct_,toCAT_,opt:OptionsPattern[]]:=Module[
  {integr,nprop=Length[vars],a,ii,tmpids,apply,toint,ann,o},

  (* integrand *)
  integr = integrfct@@(a/@Range[nprop]);

  (* convert to CATInt[...] notation *)
  toint = toCAT;

  (* IBP annihilator *)
  apply[ord_,syz_]:=CATDotIBPDerivativeList[integr syz,vars,Range[0,ord]];

  ann = Join@@#&/@annihilators;
  tmpids = Join@@Table[
    Collect[OptionValue["ApplyFunction"][
      a/@Range[nprop],
      (Collect[toint[apply[o,#]],_CATInt,Expand]&/@ann[[o]])
    ],_CATInt,Together]
  ,{o,Length[ann]}];
  Evaluate[tmpids /. a->Slot]&
]


diiftoann[ii_->expr_]:=Module[{ret=ConstantArray[{},ii]},
  ret[[ii]] = {{expr}};
  ret
]
CATIdsFromDiffOperators[diffop_,vars_,integrfct_,toCAT_,opt:OptionsPattern[]]:=Evaluate[Join@@(CATIdsFromAnnihilators[diiftoann[#],vars,integrfct,toCAT,opt]&/@diffop)[[;;,1]]]&;


CATMellinIdsFromDiffOperators[type_,annihilators_,vars_]:=CATIdsFromDiffOperators[annihilators,vars,CATMellinIntegrFct[vars],CATMellinToInt[type,vars],"ApplyFunction"->CATMellinIntApplyFct];
CATMonIdsFromDiffOperators[type_,annihilators_,vars_]:=CATIdsFromDiffOperators[annihilators,vars,CATMonIntegrFct[vars],CATMonToInt[type,vars]];
CATInvMonIdsFromDiffOperators[type_,annihilators_,vars_]:=CATIdsFromDiffOperators[annihilators,vars,CATInvMonIntegrFct[vars],CATInvMonToInt[type,vars]];


CATIntMellinDefaultWeight[CATInt[fam_,ai_]]:={
  Plus@@Select[ai,#<0&], (* remove numerators *)
  -Length[ai], (* then prefer families with fewer loop variables *)
  -Length[Select[ai,#>0&]],  (* then prefer fewer denominators *)
  (-Plus@@# + Length[#])&[Select[ai,#>0&]], (* then remove dots *)
  -Max[ai],
  Max[-ai],
  CATInt[fam,ai]
};


CATUnorderedIntCases = DeleteDuplicates[Cases[{#},_CATInt,Infinity]]&;
CATIntCases[expr_,weight_]:= SortBy[CATUnorderedIntCases[expr],weight];


CATMellinIdToLPPrefactor[nloops_,d_,exponentslhs_,exponentsrhs_]:=FunctionExpand[(((-1)^(Plus@@exponentsrhs))Gamma[(nloops+1)d/2-Plus@@(exponentsrhs)]) / (((-1)^(Plus@@exponentslhs))Gamma[(nloops+1)d/2-Plus@@(exponentslhs)])];


CATMellinToLPIdsImplem[ids_Function,nloops_,d_,lcm_]:=Module[
  {newexpr,ints,ccs,arange,a,ee},
  arange = a/@Union[Cases[{ids[[1]]},_Slot,Infinity]][[;;,1]];
  newexpr = Collect[ids@@(arange) /. CATInt->(CATMellinIdToLPPrefactor[nloops,d,arange,#2]CATInt[##]&),_CATInt,Together];
  If[TrueQ[lcm],
    newexpr = Table[
      ints = Cases[{ee},_CATInt,Infinity]//DeleteDuplicates;
      ccs=Coefficient[ee,ints];
      (Together[PolynomialLCM[Sequence@@Denominator[ccs]]ccs] . ints )
    ,{ee,newexpr}];
  ];
  Evaluate[newexpr /. a->Slot]&
]


CATMellinToLPIds[ids_Function,nloops_,d_]:=CATMellinToLPIdsImplem[ids,nloops,d,True];
CATMellinToLPDiffOperators[derivatives_Function,nloops_,d_]:=CATMellinToLPIdsImplem[derivatives,nloops,d,False];


(* shortcuts for Lee-Pomeransky loop integrals *)
CATLPIdsFromAnnihilators[family_,annihilators_,vars_,nloops_,d_]:=CATMellinToLPIds[CATMellinIdsFromAnnihilators[family,annihilators,vars],nloops,d];
CATLPIdsFromDiffOperators[family_,diffoperators_,vars_,nloops_,d_]:=CATMellinToLPDiffOperators[CATMellinIdsFromDiffOperators[family,diffoperators,vars],nloops,d];


CATMellinToSchwingerIds[ids_Function]:=Module[
  {newexpr,ints,ccs,arange,a,ee},
  arange = a/@Union[Cases[{ids[[1]]},_Slot,Infinity]][[;;,1]];
  newexpr = Collect[ids@@(arange) /. CATInt->((-1)^(Plus@@(#2-arange))CATInt[##]&),_CATInt,Together];
  Evaluate[newexpr /. a->Slot]&
]


(* shortcuts for Schwinger loop integrals *)
CATSchwingerIdsFromAnnihilators[family_,annihilators_,vars_]:=CATMellinToSchwingerIds[CATMellinIdsFromAnnihilators[family,annihilators,vars]];
CATSchwingerIdsFromDiffOperators[family_,diffoperators_,vars_]:=CATMellinToSchwingerIds[CATMellinIdsFromDiffOperators[family,diffoperators,vars]];


GetExtVData[expr_,z_]:=Module[
  {extv,ze,toslot},
  extv = Complement[Variables[{expr}],z];
  ze = Join[z,extv];
  toslot = Inner[Rule,ze,Slot/@Range[Length[ze]],List];
  {Evaluate[expr /. toslot]&,ze}
]


CATSchwinger[u_,f_,d_,z_]:=Module[
  {ze,ffun,ufun},
  {ffun,ze} = GetExtVData[{u,f},z];
  ufun = Evaluate[ffun[[1,1]]]&;
  ffun = Evaluate[ffun[[1,2]]]&;
  CATTwist[Exp[-(CATFPoly@@ze)/(CATUPoly@@ze)](CATUPoly@@ze)^(-d/2),{CATFPoly->ffun,CATUPoly->ufun}]
]


CATLP[g_,d_,z_]:=Module[
  {gfun,ze},
  {gfun,ze} = GetExtVData[g,z];
  CATTwist[(CATGPoly@@ze)^(-d/2),{CATGPoly->gfun}]
]


(* Adapted from FFIntRed by T.P. *)
Options[CATBaikovPoly]={"Cuts"->{}};
CATBaikovPoly[dens_,loopmoms_,extmoms_,replrules_,z_,OptionsPattern[]]:=Module[
  {ext,ll,vv,l1,l2,ids,P,toz,ndens,toden,
   dot,alldots,todot,loopdens,eqs,zs,cuts},

  ext = extmoms;
  ll = loopmoms;
  vv = Join[ext,ll];
  ids = replrules;
  ndens = Length[dens];
  zs = z/@Range[Length[dens]];
  cuts = z[#]->0&/@OptionValue["Cuts"];

  (* convert SPs to z *)
  todot = DeleteDuplicates[Join@@Outer[#1 #2 -> dot@@Sort[{#1,#2}]&,loopmoms,Join[loopmoms,extmoms]]];
  toden[{k_,m2_}]:=k^2-m2;
  toden[{k_,v_,m2_}]:=k v - m2;
  loopdens = Expand[toden/@(dens)]/.ids/.todot//Expand;
  eqs = Inner[Equal,zs/.cuts,loopdens,List];
  alldots = todot[[;;,2]];
  toz = FFSparseSolve[eqs,Join[alldots,zs]];
  If[Length[Complement[alldots,toz[[;;,1]]]]>0,
    Message[CATBaikovPoly::invspdenoms];
    Return[$Failed];
  ];
  If[Length[Intersection[zs,toz[[;;,1]]]]>0,
    Message[CATBaikovPoly::redundantdenoms];
    Return[$Failed];
  ];

  P = Expand[Det[Table[2 l1 l2 /. todot,{l1,vv},{l2,vv}]/.ids]/.toz];
  (*exp = (d-L-E-1)/2;*)
  {P,Complement[zs,cuts[[;;,1]]]}
];


CATBaikovExponent[d_,L_,E_]:=(d-L-E-1)/2;
CATBaikovImpl[B_,d_,L_,E_,z_,expsign_]:=Module[
  {bfun,exp,ze},
  {bfun,ze} = GetExtVData[B,z];
  exp = expsign*CATBaikovExponent[d,L,E];
  CATTwist[(CATBPoly@@ze)^exp,{CATBPoly->bfun}]
];
CATBaikov[B_,d_,L_,E_,z_]:=CATBaikovImpl[B,d,L,E,z,1];
CATBaikovDual[B_,d_,L_,E_,z_]:=CATBaikovImpl[B,d,L,E,z,-1];


CATMultiBaikov[b_List,exp_List,exparg_,z_]:=Module[
  {bfun,expafun,ze,ii},
  {bfun,ze} = GetExtVData[Join[b,{exparg}],z];
  expafun = Evaluate[bfun[[1]][[-1]]]&;
  bfun = Table[Evaluate[bb]&,{bb,bfun[[1,;;-2]]}];
  CATTwist[
    Product[(CATBPoly[ii]@@ze)^exp[[ii]],{ii,Length[b]}]*
    If[exparg===0,1,Exp[CATBPoly[Length[b]+1]@@ze]],
    Join[
      Table[CATBPoly[ii]->bfun[[ii]],{ii,Length[b]}],
      If[exparg===0,{},{CATBPoly[Length[b]+1]->expafun}]
    ]
  ]
];
CATMultiBaikov[b_List,exp_List,z_]:=CATMultiBaikov[b,exp,0,z];


CATDualDeriv[a_List,ord_]:=CATDualDeriv[#,ord]&/@a;
CATDualDeriv[a_Plus,ord_]:=CATDualDeriv[#,ord]&/@a;
CATDualDeriv[a_Times,ord_]:=Plus@@(MapAt[CATDualDeriv[#,ord]&,a,#]&/@Range[Length[a]]);
CATDualDeriv[expr_,ord_]:=0;
CATDualDeriv[CATInt[f_,a_],ord_List]:=(
  CATIntDualDerivImpl[f,a,Join@@(ConstantArray[#,ord[[#]]]&/@Range[Length[ord]])]
)


CATDualRegulated[f_]:=(Message[CATDualRegulated::undefined,f];$Failed);


CATIntDualDerivImpl[f_,a_,{}]:=CATInt[f,a];
CATIntDualDerivImpl[f_,a_,d_]:=-(a[[d[[1]]]] - KroneckerDelta[0,a[[d[[1]]]]]CATDualRegulated[f][[d[[1]]]])CATIntDualDerivImpl[f,a+UnitVector[Length[a],d[[1]]],d[[2;;]]];


CATDotDualDerivativeListImplem[expr_List,vars_,ordi_]:=Module[
  {ords,ii,sign=-1,order},
  order = Range[0,ordi];
  ords = Join@@(CATExponentList[#,Length[vars]]&/@order);
  If[!TrueQ[Length[ords]==Length[expr]],
    Message[CATDotDerivativeList::baddim,Length[ords]];
    Return[$Failed];
  ];
  Sum[sign^(Plus@@ords[[ii]]) CATDualDeriv[expr[[ii]],ords[[ii]]],{ii,Length[ords]}]
];


CATDualInvMonIdsFromAnnihilators[family_,ann_,vars_]:=Module[
  {n=Length[vars],catann,catcond,catannphi,ii,a,as,annlist},
  
  (* annihilators in CATInt notation *)
  catann = Expand[ CATInt[family,ConstantArray[0,n]] ann/. Table[vars[[ii]] -> CATInt[family,-UnitVector[n,ii]],{ii,n}]];
  
  (* rule for monomial multiplication *)
  as = a/@Range[n];
  catcond  = CATInt[family, b_ ] :> CATInt[family, b + as ] If [ And@@Table[(a[ii]>-b[[ii]] || a[ii] <= 0),{ii,n}], 1 ,0];
  
  (* multiply c[i] by phi *)
  catannphi = catann/.catcond;
  
  Evaluate[Flatten[Table[
    annlist = Join@@catannphi[[ordii]];
	Table[
		CATDotDualDerivativeListImplem[annlist[[ii]],vars,ordii]
	,{ii,1,Length[annlist]}]
  ,{ordii,1,Length[catannphi]}]]/.a->Slot]&
];


CATDualInvMonIdsFromDiffOperators[family_,diffop_,vars_]:=Module[
  {convert,ii},
  Evaluate[Join@@Table[
    convert = ConstantArray[{},diffop[[ii,1]]];
    convert[[diffop[[ii,1]]]] = {{diffop[[ii,2]]}};
    CATDualInvMonIdsFromAnnihilators[family,convert,vars][[1]]
  ,{ii,Length[diffop]}]]&
];


CATIntDualInvMonDefaultWeight[CATInt[fam_,ai_]]:={
  (-Plus@@# + Length[#])&[Select[ai,#>0&]], (* remove dots *)
  -Length[ai], (* prefer families with fewer loop variables *)
  Length[Select[ai,#>0&]],  (* then prefer more denominators *)
  Plus@@Select[ai,#<0&], (* the fewer numerators *)
  -Max[ai],
  Max[-ai],
  CATInt[fam,ai]
};


CATIntInvMonDefaultWeight[CATInt[fam_,ai_List]]:={
  (-Plus@@# + Length[#])&[Select[ai,#>0&]], (* remove dots *)
  -Length[ai], (* prefer families with fewer loop variables *)
  -Length[Select[ai,#>0&]],  (* then prefer fewer denominators *)
  Plus@@Select[ai,#<0&], (* the fewer numerators *)
  -Max[ai],
  Max[-ai],
  CATInt[fam,ai]
}


CATApplyAnnihililators[ann_,vars_,expr_]:=Table[Map[CATDerivativeList[expr,vars,Range[0,order]] . # &, ann[[order]],{2}],{order,1,Length[ann]}];
CATApplyDiffOperators[diffop_,params_,vars_,expr_]:=Map[CATDerivativeList[expr,vars,Range[0,#[[1]]]] . #[[2]] &, diffop];


End[] (* "`Private`" *)


EndPackage[] (* "CALICO`" *)
